<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-06-08 Wed 15:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>gevent源码分析</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Yu Yang" />
<meta  name="keywords" content="gevent python coroutine" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">gevent源码分析</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline3">基本概念</a>
<ul>
<li><a href="#orgheadline1">continuation</a></li>
<li><a href="#orgheadline2">coroutine</a></li>
</ul>
</li>
<li><a href="#orgheadline4">gevent背景知识</a>
<ul>
<li><a href="#orgheadline5">greenlet</a>
<ul>
<li><a href="#orgheadline6">api</a></li>
</ul>
</li>
<li><a href="#orgheadline7">libev</a></li>
</ul>
</li>
<li><a href="#orgheadline8">gevent源码分析</a>
<ul>
<li><a href="#orgheadline9">core</a>
<ul>
<li><a href="#orgheadline10">core源码分析</a></li>
<li><a href="#orgheadline11">core的api总结</a></li>
</ul>
</li>
<li><a href="#orgheadline12">HUB</a>
<ul>
<li><a href="#orgheadline13">Waiter</a></li>
</ul>
</li>
<li><a href="#orgheadline14">Greenlet</a></li>
<li><a href="#orgheadline15">socket模块</a></li>
<li><a href="#orgheadline16">timeout模块</a>
<ul>
<li><a href="#orgheadline17">timeout使用指南</a></li>
</ul>
</li>
<li><a href="#orgheadline18">Event</a>
<ul>
<li><a href="#orgheadline19">Event使用指南</a></li>
</ul>
</li>
<li><a href="#orgheadline20">AsycResult</a></li>
<li><a href="#orgheadline21">queue</a></li>
<li><a href="#orgheadline23">channel</a>
<ul>
<li><a href="#orgheadline22">channel使用指南</a></li>
</ul>
</li>
<li><a href="#orgheadline24">其它</a></li>
</ul>
</li>
<li><a href="#orgheadline25">第三方库</a>
<ul>
<li><a href="#orgheadline26">greenify</a></li>
<li><a href="#orgheadline27">PyMongo</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">基本概念</h2>
<div class="outline-text-2" id="text-orgheadline3">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">continuation</h3>
<div class="outline-text-3" id="text-orgheadline1">
<p>
    continuation是一个程序设计语言理论上的概念，不怕英文的童鞋可以
看这一篇<a href="http://en.wikipedia.org/wiki/Continuation">wiki</a>, 你可以将continuation看成是一个数据结构，这个数据结构
可以保存程序的执行流的状态，而且可以在程序中访问这个数据结构来恢复
程序的执行流，这就赋予了程序一种能力，也就是说我可以先获得一个
continuation，接着挂起一个程序正在执行的部分，然后跳到该程序的其他
部分执行，以后又可以通过调用continuation来恢复被挂起的执行流。这种
能力为异常，触发器以及协程的实现提供非常了便利的条件。某种程度上而
言，continuation是这些实现这些程序语言设施的基础
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span class="linenr"> 1: </span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #93E0E3;">the-continuation</span> #f<span style="color: #DCDCCC;">)</span>
<span class="linenr"> 2: </span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">define</span> <span style="color: #BFEBBF;">(</span><span style="color: #93E0E3;">test</span><span style="color: #BFEBBF;">)</span>
<span class="linenr"> 3: </span>  <span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">let</span> <span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span>i <span style="color: #BFEBBF;">0</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
<span class="linenr"> 4: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">call/cc calls its first function argument, passing</span>
<span class="linenr"> 5: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">a continuation variable representing this point in</span>
<span class="linenr"> 6: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">the program as the argument to that function.</span>
<span class="linenr"> 7: </span>    <span style="color: #5F7F5F;">;;</span>
<span class="linenr"> 8: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">In this case, the function argument assigns that</span>
<span class="linenr"> 9: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">continuation to the variable the-continuation.</span>
<span class="linenr">10: </span>    <span style="color: #5F7F5F;">;;</span>
<span class="linenr">11: </span>    <span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">call/cc</span> <span style="color: #93E0E3;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> <span style="color: #9FC59F;">(</span>k<span style="color: #9FC59F;">)</span> <span style="color: #9FC59F;">(</span>set! the-continuation k<span style="color: #9FC59F;">)</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
<span class="linenr">12: </span>    <span style="color: #5F7F5F;">;;</span>
<span class="linenr">13: </span>    <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">The next time the-continuation is called, we start here.</span>
<span class="linenr">14: </span>    <span style="color: #D0BF8F;">(</span>set! i <span style="color: #93E0E3;">(</span>+ i <span style="color: #BFEBBF;">1</span><span style="color: #93E0E3;">)</span><span style="color: #D0BF8F;">)</span>
<span class="linenr">15: </span>    i<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
上述是一段scheme代码，摘自wikipedia。我大体的解释下这段代码，一开始
定义了一个变量the-continuation，接着定义一个函数test，在函数体中let
定义一个局部变量i，接着调用call/cc，该函数的作用可以看注释，call/cc
的第一个参数是一个函数，call/cc的作用是将代表当前continuation的一个
变量作为参数传递给它的第一个参数，对本例而言就是将代表当前
continuation的变量传递给那个lambda匿名函数，而这个匿名函数会将
the-continuation设置为当前的continuation，所以运行
</p>
<pre class="example">
(test)
=&gt; 1
(the-continuation)
=&gt;2
(the-continuation)
=&gt;3
</pre>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">coroutine</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
Coroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同
的例程的意思, 实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的
轻量级进程,所以我们来比较一下进程与协程的异同:
</p>
<ul class="org-ul">
<li><p>
<b>相同点</b>:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在
你挂起的地方恢复执行, 这实际上都可以看做是continuation, 我们来看看当我们挂
起一个执行流时我们要保存的东西
</p>
<ol class="org-ol">
<li><b>栈</b>, 因为如果你不保存栈,那么局部变量你就无法恢复,同时函数的调用链你也无
法恢复,</li>
<li><b>寄存器的状态</b>: 这好理解, 比如说EIP,如果你不保存,那么你恢复执行流就不知道
到底执行哪一条指令, 在比如说ESP,EBP, 如果你不保存,那么你即便有完整的栈
你也不知道怎么用.</li>
</ol>
<p>
这二者实际就是所谓的上下文,也可以说是continuation. 在执行流切换时必须保存
这两个东西, 内核调度进程时也是一回事.
</p></li>
<li><b>不同点</b>:
<ol class="org-ol">
<li>执行流的调度者不同, 进程是内核调度, 而协程是在用户态调度, 也就是说进程
的上下文是在内核态保存恢复的,而协程是在用户态保存恢复的. 很显然用户态的
代价更低</li>
<li>进程会被抢占,而协程不会,也就是说协程如果不主动让出CPU,那么其他的协程是不
可能得到执行机会,这实际和早期的操作系统类似,比如DOS, 它有一个yield原语,
一个进程调用yield,那么它就会让出CPU, 其他的进程也就有机会执行了, 如果一
个进程进入了死循环,那么整个系统也就挂起了,永远无法运行其他的进程了, 但
对协程而言,这不是问题</li>
<li>对内存的占用不同,实际上协程可以只需要4K的栈就够了, 而进程占用的内存要大
的多.</li>
<li>从操作系统的角度讲, 多协程的程序是单线程,单进程的</li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">gevent背景知识</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
gevent用到了了libev以及greenlet还有cares,下面简单的介绍这几个库.
</p>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">greenlet</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
实际是一个协程库(官方叫micro-thread), 它只提供协程本身,要在协程间切
换调度必须你在程序中手动来进行,直接上代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test1</span><span style="color: #DCDCCC;">(</span>x, y<span style="color: #DCDCCC;">)</span>:
    <span style="color: #DFAF8F;">z</span> = gr2.switch<span style="color: #DCDCCC;">(</span>x+y<span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">print</span> z

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test2</span><span style="color: #DCDCCC;">(</span>u<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">print</span> u
    gr1.switch<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">42</span><span style="color: #DCDCCC;">)</span>

<span style="color: #DFAF8F;">gr1</span> = greenlet<span style="color: #DCDCCC;">(</span>test1<span style="color: #DCDCCC;">)</span>
<span style="color: #DFAF8F;">gr2</span> = greenlet<span style="color: #DCDCCC;">(</span>test2<span style="color: #DCDCCC;">)</span>
gr1.switch<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">"hello"</span>, <span style="color: #CC9393;">" world"</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
gr1, gr2以及运行该代码的解释器本身都是协程, 协程对象的switch方法用
来切换,比如 <code>gr2.switch</code> 就是切换到gr2.
</p>
</div>
<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">api</h4>
<div class="outline-text-4" id="text-orgheadline6">
<ol class="org-ol">
<li>greenlet(run=None, parent=None): 创建一个greenlet实例.</li>
<li>greenlet.getcurrent:</li>
</ol>
<p>
实例方法与属性
</p>
<ol class="org-ol">
<li>gr.parent:每一个协程都有一个父协程,当前协程结束后会回到父协程中执行,该
属性默认是创建该协程的协程.</li>
<li>gr.run: 该属性是协程实际运行的代码. run方法结束了,那么该协程也就结束了.</li>
<li>gr.switch(*args, **kwargs): 切换到gr协程.</li>
<li>gr.throw(): 切换到gr协程,接着抛出一个异常.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">libev</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
和libevent类似, libev是一个事件循环库,他可以监听各个file descriptor, 一旦发现
就绪就调用对应的回调函数, gevent内部就是使用libev来监听socket的.为了后续理解
方便有必要对libev进行简单的了解.
</p>
<ol class="org-ol">
<li>watcher: 实际上是用来封装各种类型的事件的,不同类型的事件会有不同类型的
watcher, 比如 <code>ev_io</code>, <code>ev_timer</code>, 该结构一般会有一个回调函数,当事件触发
使就会调用回调函数. watcher会有两种函数(注意TYPE代表watcher类型,可以是
io, timer, signal等等):
<ul class="org-ul">
<li>ev_TYPE_init: 对watcher对象进行初始化, 对IO而言该函数是 <code>ev_io_init</code>,
对timer而言,该函数是 <code>ev_timer_init</code>.</li>
<li>ev_TYPE_set: 与init系列函数的区别是该函数一般不设置callback</li>
<li>ev_TYPE_start: 将watcher注册到事件循环中,这样就可以监听事件了.</li>
</ul></li>
<li>loop: 事件循环</li>
</ol>
<p>
来看看示例代码:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">a single header file is required</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;ev.h&gt;</span>

<span style="color: #94BFF3;">#include</span> <span style="color: #DCDCCC;">&lt;</span><span style="color: #CC9393;">stdio.h</span><span style="color: #DCDCCC;">&gt;</span> <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">for puts</span>

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">every watcher type has its own typedef'd struct</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">with the name ev_TYPE</span>
<span style="color: #7CB8BB;">ev_io</span> <span style="color: #DFAF8F;">stdin_watcher</span>;
<span style="color: #7CB8BB;">ev_timer</span> <span style="color: #DFAF8F;">timeout_watcher</span>;

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">all watcher callbacks have a similar signature</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">this callback is called when data is readable on stdin</span>
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span>
<span style="color: #93E0E3;">stdin_cb</span> <span style="color: #DCDCCC;">(</span>EV_P_ <span style="color: #7CB8BB;">ev_io</span> *<span style="color: #DFAF8F;">w</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">revents</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">{</span>
    puts <span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">"stdin ready"</span><span style="color: #BFEBBF;">)</span>;
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">for one-shot events, one must manually stop the watcher</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">with its corresponding stop function.</span>
    ev_io_stop <span style="color: #BFEBBF;">(</span><span style="color: #7CB8BB;">EV_A_</span> <span style="color: #DFAF8F;">w</span><span style="color: #BFEBBF;">)</span>;

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">this causes all nested ev_run's to stop iterating</span>
    ev_break <span style="color: #BFEBBF;">(</span><span style="color: #7CB8BB;">EV_A_</span> <span style="color: #DFAF8F;">EVBREAK_ALL</span><span style="color: #BFEBBF;">)</span>;
<span style="color: #DCDCCC;">}</span>

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">another callback, this time for a time-out</span>
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span>
<span style="color: #93E0E3;">timeout_cb</span> <span style="color: #DCDCCC;">(</span>EV_P_ <span style="color: #7CB8BB;">ev_timer</span> *<span style="color: #DFAF8F;">w</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">revents</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">{</span>
    puts <span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">"timeout"</span><span style="color: #BFEBBF;">)</span>;
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">this causes the innermost ev_run to stop iterating</span>
    ev_break <span style="color: #BFEBBF;">(</span><span style="color: #7CB8BB;">EV_A_</span> <span style="color: #DFAF8F;">EVBREAK_ONE</span><span style="color: #BFEBBF;">)</span>;
<span style="color: #DCDCCC;">}</span>

<span style="color: #7CB8BB;">int</span>
<span style="color: #93E0E3;">main</span> <span style="color: #DCDCCC;">(</span><span style="color: #7CB8BB;">void</span><span style="color: #DCDCCC;">)</span>
<span style="color: #DCDCCC;">{</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">use the default event loop unless you have special needs</span>
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">ev_loop</span> *<span style="color: #DFAF8F;">loop</span> = EV_DEFAULT;

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">initialise an io watcher, then start it</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">this one will watch for stdin to become readable</span>
    ev_io_init <span style="color: #BFEBBF;">(</span>&amp;stdin_watcher, stdin_cb, <span style="color: #5F7F5F;">/*</span><span style="color: #7F9F7F;">STDIN_FILENO</span><span style="color: #5F7F5F;">*/</span> <span style="color: #BFEBBF;">0</span>, EV_READ<span style="color: #BFEBBF;">)</span>;
    ev_io_start <span style="color: #BFEBBF;">(</span>loop, &amp;stdin_watcher<span style="color: #BFEBBF;">)</span>;

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">initialise a timer watcher, then start it</span>
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">simple non-repeating 5.5 second timeout</span>
    ev_timer_init <span style="color: #BFEBBF;">(</span>&amp;timeout_watcher, timeout_cb, <span style="color: #BFEBBF;">5</span>.<span style="color: #BFEBBF;">5</span>, <span style="color: #BFEBBF;">0</span>.<span style="color: #BFEBBF;">)</span>;
    ev_timer_start <span style="color: #BFEBBF;">(</span>loop, &amp;timeout_watcher<span style="color: #BFEBBF;">)</span>;

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">now wait for events to arrive</span>
    ev_run <span style="color: #BFEBBF;">(</span>loop, <span style="color: #BFEBBF;">0</span><span style="color: #BFEBBF;">)</span>;

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">break was called, so exit</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">0</span>;
<span style="color: #DCDCCC;">}</span>
</pre>
</div>
<p>
获得loop对象, 创建一个io watcher,一个timer watcher, 分别初始化(调用init函
数),然后调用start注册回调函数到事件循环中, 接着调用ev_run启动事件循环.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">gevent源码分析</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
开始之前先申明: <b>本文分析的是gevent1.0</b>.
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">core</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
core.ppyx文件实际上是用Cython写的代码，在Makefile中有这样一行代码:
</p>
<pre class="example">
gevent/gevent.core.c: gevent/core.ppyx gevent/libev.pxd
        $(PYTHON) util/cythonpp.py -o gevent.core.c gevent/core.ppyx
        echo                          &gt;&gt; gevent.core.c
        echo '#include "callbacks.c"' &gt;&gt; gevent.core.c
        mv gevent.core.* gevent/
</pre>
<p>
上面的代码告诉我们core.ppyx会先转换为gevent.core.c这个C语言文件,然后在编译成
动态链接库，它的语法基本能看懂, 这个模块主要是实现loop这个类, hub对象中的
loop就是这个类的一个对象(注意名字虽然相同但一个是类,一个对象,不要弄混),这个
类将libev的事件循环机制封装了起来,我们先熟悉下这个类提供的API,熟悉这些API对
使用gevent很有帮助,我假设lp是loop类的对象(在gevent中就是get_hub().loop)
</p>
<pre class="example">
def io(self, int fd, int events, ref=True, priority=None):
    return io(self, fd, events, ref, priority)

def timer(self, double after, double repeat=0.0, ref=True, priority=None):
    return timer(self, after, repeat, ref, priority)

def signal(self, int signum, ref=True, priority=None):
    return signal(self, signum, ref, priority)

def idle(self, ref=True, priority=None):
    return idle(self, ref, priority)

def prepare(self, ref=True, priority=None):
    return prepare(self, ref, priority)

def fork(self, ref=True, priority=None):
    return fork(self, ref, priority)

def async(self, ref=True, priority=None):
    return async(self, ref, priority)
</pre>
<p>
注意上面是Cython, 上面的一系列方法实际是libev中watcher的等价物.比如你调用
<code>lp.io(fd, 1)</code>, 就创建了一个监听fd的read事件的watcher对象,至于其它的api都是
类似, 每一个watcher对象都有一个 <code>start</code> 方法, 该方法接受一个回调函数以及一系
列传递给回调函数的参数, 调用该方法就会将watcher对象注册到libev的事件循环上,
看下面的示例:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">read_watcher</span> = lp.io<span style="color: #DCDCCC;">(</span>fd, <span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span>
read_watcher.start<span style="color: #DCDCCC;">(</span>cb, args<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
运行上面的两行代码,那么当fd上读就绪时,那么就会调用cb函数,并且会把args传递给
cb函数.在gevent中回调函数一般是协程的switch方法, 这样一旦调用,那么就切换到
另一个协程中去执行.
</p>
</div>
<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">core源码分析</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
这一节来分析core.ppyx的源码, 在一次提醒你注意,代码是Cython, 我对Cython也不
太熟,但是代码大致能看懂. 同时要明白该模块是对libev的封装, libev中loop,
watcher,callback在该模块中都有对应物, 所以你要注意当提到loop时,我们到底是
该模块的loop还是libev的loop.
</p>
<ol class="org-ol">
<li><p>
先看callback
</p>
<pre class="example">
cdef public class callback [object PyGeventCallbackObject, type PyGeventCallback_Type]:
    cdef public object callback
    cdef public tuple args

    def __init__(self, callback, args):
        self.callback = callback
        self.args = args

    def stop(self):
        self.callback = None
        self.args = None
</pre>
<p>
实际上就是把回调函数以及要提供给回调函数的参数封装了起来.
</p></li>
<li><p>
loop: 事件循环的封装.
</p>
<pre class="example">
cdef public class loop [object PyGeventLoopObject, type PyGeventLoop_Type]:
    cdef libev.ev_loop* _ptr
    cdef public object error_handler
    cdef libev.ev_prepare _prepare
    cdef public list _callbacks
    cdef libev.ev_timer _timer0

    def __init__(self, object flags=None, object default=None, size_t ptr=0):
        cdef unsigned int c_flags
        cdef object old_handler = None
        libev.ev_prepare_init(&amp;self._prepare, &lt;void*&gt;gevent_run_callbacks)
        libev.ev_timer_init(&amp;self._timer0, &lt;void*&gt;gevent_noop, 0.0, 0.0)
        if ptr:
            self._ptr = &lt;libev.ev_loop*&gt;ptr
        else:
            ......

        self._callbacks = []
</pre>
<ol class="org-ol">
<li>_ptr: libev的一个ev_loop对象.</li>
<li>_prepare: libev中的prepare watcher,该watcher注册的回调函数会在事件循环进
入阻塞时调用, 从代码中可以看到注册的回调函数是 <code>gevent_run_callbacks</code>,
该函数会运行 <code>_callbacks</code> 列表中的每一个callback实例.</li>
<li>_callbacks: 一个列表,实际上当你使用gevent的spawn创建协程时, spawn会在
该列表中插入一个callback实例, 该实例的回调函数实际就是你创建的
greenlet的switch方法, 这样当 <code>_prepare</code> watcher就绪时,新的协程就有了
启动的机会.</li>
</ol></li>
<li><p>
watcher: 这是libev的watcher对象的封装,作为例子,我只分析io这一个例
子,timer,signal等等都是相似的, 为了方便我使用cwatcher来指代libev中的
watcher.
</p>
<pre class="example">
#define WATCHER_BASE(TYPE)                                            \
    cdef public loop loop                                             \
    cdef object _callback                                             \
    cdef public tuple args                                            \
    cdef readonly int _flags                                          \
    cdef libev.ev_##TYPE _watcher                                     \

cdef public class io(watcher) [object PyGeventIOObject, type PyGeventIO_Type]:

    WATCHER_BASE(io)

    def start(self, object callback, *args, pass_events=False):
        CHECK_LOOP2(self.loop)
        if callback is None:
            raise TypeError('callback must be callable, not None')
        self.callback = callback
        if pass_events:
            self.args = (GEVENT_CORE_EVENTS, ) + args
        else:
            self.args = args
        LIBEV_UNREF
        libev.ev_io_start(self.loop._ptr, &amp;self._watcher)

    def __init__(self, loop loop, int fd, int events, ref=True, priority=None):
        if fd &lt; 0:
            raise ValueError('fd must be non-negative: %r' % fd)
        if events &amp; ~(libev.EV__IOFDSET | libev.EV_READ | libev.EV_WRITE):
            raise ValueError('illegal event mask: %r' % events)
        libev.ev_io_init(&amp;self._watcher, &lt;void *&gt;gevent_callback_io, fd, events)
        self.loop = loop
        if ref:
            self._flags = 0
        else:
            self._flags = 4
        if priority is not None:
            libev.ev_set_priority(&amp;self._watcher, priority)
</pre>
<ol class="org-ol">
<li>WATCH_BASE, 它实际上定义了一系列的属性:
<ul class="org-ul">
<li>loop: 实际是上面分析的loop类的一个实例</li>
<li>_watcher: cwatcher对象,也就是一个libev的ev_io对象.</li>
<li>callback: 回调函数, 注意该回调函数是由上层传递进来,它不是由libev直接
调用,而是由libev的回调函数调用,具体到本例就是被 <code>gevent_callback_io</code>
调用.</li>
<li>args: 一个元组,传递给回调函数的参数</li>
</ul></li>
<li>__init__: 该函数会设置loop属性,同时初始化libev的io watcher对象
<code>_watcher</code> (主要做两件事: 指定事件类型,指定回调函数), 注意它的回调函数
是 <code>gevent_callback_io</code></li>
<li>start: 该函数中 会设置回调函数以及参数, 这里设置的回调函数是上层传入的,
不要和libev的回调函数混淆, 同时调用 <code>ev_io_start</code> 将该watcher注册到
libev的事件循环中. 为了弄明白libev事件循环的过程,我接下来分析
<code>gevent_callback_io</code>.</li>
<li><p>
gevent_callback_io
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">GET_OBJECT</span><span style="color: #DCDCCC;">(</span><span style="color: #DFAF8F;">PY_TYPE</span>, <span style="color: #DFAF8F;">EV_PTR</span>, <span style="color: #DFAF8F;">MEMBER</span><span style="color: #DCDCCC;">)</span>                             \
    <span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">(</span><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">PY_TYPE</span> *<span style="color: #BFEBBF;">)(</span><span style="color: #D0BF8F;">(</span><span style="color: #93E0E3;">(</span><span style="color: #7CB8BB;">char</span> *<span style="color: #93E0E3;">)</span>EV_PTR<span style="color: #D0BF8F;">)</span> - offsetof<span style="color: #D0BF8F;">(</span><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">PY_TYPE</span>, MEMBER<span style="color: #D0BF8F;">)</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">gevent_callback_io</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">ev_loop</span> *<span style="color: #DFAF8F;">_loop</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">c_watcher</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">revents</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">PyGeventIOObject</span>* <span style="color: #DFAF8F;">watcher</span> = GET_OBJECT<span style="color: #BFEBBF;">(</span>PyGeventIOObject, c_watcher, _watcher<span style="color: #BFEBBF;">)</span>;
    gevent_callback<span style="color: #BFEBBF;">(</span>watcher-&gt;loop, watcher-&gt;_callback, watcher-&gt;args, <span style="color: #D0BF8F;">(</span><span style="color: #7CB8BB;">PyObject</span>*<span style="color: #D0BF8F;">)</span>watcher, c_watcher, revents<span style="color: #BFEBBF;">)</span>;
<span style="color: #DCDCCC;">}</span>
</pre>
</div>
<p>
GET_OBJECT的作用是通过结构体中某一个域的指针来获得整个结构体的指针. 如果
你熟悉linux内核就会发现它和container_of的功能很相似. 所以这里实际就是根
据cwatcher对象_watcher来获得watcher的指针, 接着就调用
<code>gevent_callback</code>.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">gevent_callback</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">PyGeventLoopObject</span>* <span style="color: #DFAF8F;">loop</span>, <span style="color: #7CB8BB;">PyObject</span>* <span style="color: #DFAF8F;">callback</span>,
                            <span style="color: #7CB8BB;">PyObject</span>* <span style="color: #DFAF8F;">args</span>, <span style="color: #7CB8BB;">PyObject</span>* <span style="color: #DFAF8F;">watcher</span>, <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">c_watcher</span>,
                            <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">revents</span><span style="color: #DCDCCC;">)</span> <span style="color: #DCDCCC;">{</span>
    ......
    result = PyObject_Call<span style="color: #BFEBBF;">(</span>callback, args, <span style="color: #BFEBBF;">NULL</span><span style="color: #BFEBBF;">)</span>;
    ......
<span style="color: #DCDCCC;">}</span>
</pre>
</div>
<p>
所以该函数就调用了上层传入的callback.
</p></li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">core的api总结</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
假设Loop代表类, loop代表实例
</p>
<ol class="org-ol">
<li>loop.run: 启动事件循环</li>
<li>loop.run_callback(fun, *args): 将fun注册给loop的_prepare watcher,这样
fun就会在事件循环要阻塞时运行, spawn以及rawlink都会使用该方法.</li>
<li>loop.io: 创建一个IO watcher实例, 调用该实例的start方法来注册回调函数,同
时将该watcher放入事件循环.</li>
<li>loop.timer: 创建Timer Watcher对象</li>
<li>loop.signal: 创建signal Watcher对象</li>
<li>loop.idle:</li>
<li>loop.prepare:</li>
<li>loop.fork:</li>
</ol>
<p>
<b>注意使用io,timer, signal</b> 等方法创建watcher对象后, 必须调用该对象start方法
才能将watcher注册到事件循环中
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">HUB</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
这实际上是greenlet的子类,所以它的每一个实例实际上就代表一个协程,这个类创建的
协程是专门用来运行事件循环的.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Hub</span><span style="color: #DCDCCC;">(</span>greenlet<span style="color: #DCDCCC;">)</span>:
    ...

    <span style="color: #DFAF8F;">NOT_ERROR</span> = <span style="color: #DCDCCC;">(</span>GreenletExit, <span style="color: #7CB8BB;">SystemExit</span><span style="color: #DCDCCC;">)</span>
    <span style="color: #DFAF8F;">loop_class</span> = config<span style="color: #DCDCCC;">(</span><span style="color: #CC9393;">'gevent.core.loop'</span>, <span style="color: #CC9393;">'GEVENT_LOOP'</span><span style="color: #DCDCCC;">)</span>
    ...
    <span style="color: #DFAF8F;">backend</span> = config<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">None</span>, <span style="color: #CC9393;">'GEVENT_BACKEND'</span><span style="color: #DCDCCC;">)</span>
    ...

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, loop=<span style="color: #BFEBBF;">None</span>, default=<span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>:
        greenlet.__init__<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">hasattr</span><span style="color: #DCDCCC;">(</span>loop, <span style="color: #CC9393;">'run'</span><span style="color: #DCDCCC;">)</span>:
           ...
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            ...
            <span style="color: #DFAF8F;">loop_class</span> = _import<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.loop_class<span style="color: #DCDCCC;">)</span>
            <span style="color: #F0DFAF; font-weight: bold;">if</span> loop <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
                <span style="color: #DFAF8F;">loop</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.backend
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.loop = loop_class<span style="color: #DCDCCC;">(</span>flags=loop, default=default<span style="color: #DCDCCC;">)</span>
        ...
</pre>
</div>
<p>
创建一个hub实例, 这个实例最重要的就是loop属性,这个实际就是core模块的loop类的
实例,也就是说是libev的事件循环的封装.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">run</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #F0DFAF; font-weight: bold;">self</span> <span style="color: #F0DFAF; font-weight: bold;">is</span> getcurrent<span style="color: #DCDCCC;">()</span>, <span style="color: #CC9393;">'Do not call Hub.run() directly'</span>
    <span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #BFEBBF;">True</span>:
        <span style="color: #DFAF8F;">loop</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.loop
        <span style="color: #DFAF8F;">loop.error_handler</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            loop.run<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">finally</span>:
            <span style="color: #DFAF8F;">loop.error_handler</span> = <span style="color: #BFEBBF;">None</span>  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">break the refcount cycle</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.parent.throw<span style="color: #DCDCCC;">(</span>LoopExit<span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">'This operation would block forever'</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
这个方法就是协程的入口函数,它内部实际是一个循环, 这个循环就是用来启动libev的
事件循环的. 该函数一般是在调用 <code>hub.switch</code> 时开始运行的.
</p>
</div>
<div id="outline-container-orgheadline13" class="outline-4">
<h4 id="orgheadline13">Waiter</h4>
<div class="outline-text-4" id="text-orgheadline13">
<p>
协程间的通信机制.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Waiter</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, hub=<span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> hub <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub = get_hub<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub = hub
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet = <span style="color: #BFEBBF;">None</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.value = <span style="color: #BFEBBF;">None</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._exception = _NONE

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">get</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""If a value/an exception is stored, return/raise it. Otherwise until switch() or throw() is called."""</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>._exception <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> _NONE:
            <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>._exception <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.value
            <span style="color: #F0DFAF; font-weight: bold;">else</span>:
                getcurrent<span style="color: #DCDCCC;">()</span>.throw<span style="color: #DCDCCC;">(</span>*<span style="color: #F0DFAF; font-weight: bold;">self</span>._exception<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>, <span style="color: #CC9393;">'This Waiter is already used by %r'</span> % <span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet, <span style="color: #DCDCCC;">)</span>
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet = getcurrent<span style="color: #DCDCCC;">()</span>
            <span style="color: #F0DFAF; font-weight: bold;">try</span>:
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub.switch<span style="color: #DCDCCC;">()</span>
            <span style="color: #F0DFAF; font-weight: bold;">finally</span>:
                <span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet = <span style="color: #BFEBBF;">None</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">switch</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, value=<span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""Switch to the greenlet if one's available. Otherwise store the value."""</span>
        <span style="color: #DFAF8F;">greenlet</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.greenlet
        <span style="color: #F0DFAF; font-weight: bold;">if</span> greenlet <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.value = value
            <span style="color: #F0DFAF; font-weight: bold;">self</span>._exception = <span style="color: #BFEBBF;">None</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">assert</span> getcurrent<span style="color: #DCDCCC;">()</span> <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub, <span style="color: #CC9393;">"Can only use Waiter.switch method from the Hub greenlet"</span>
            <span style="color: #DFAF8F;">switch</span> = greenlet.switch
            <span style="color: #F0DFAF; font-weight: bold;">try</span>:
                switch<span style="color: #DCDCCC;">(</span>value<span style="color: #DCDCCC;">)</span>
            <span style="color: #F0DFAF; font-weight: bold;">except</span>:
                <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub.handle_error<span style="color: #DCDCCC;">(</span>switch, *sys.exc_info<span style="color: #BFEBBF;">()</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
该类的实例有一个value属性, 一个_expception属性, 一个get方法,一个switch方法,他
们的行为是这样的:
</p>
<ol class="org-ol">
<li>get: 当你在一个协程中调用get方法时, 它会先检查_exception的值,如果不为默
认的_NONE, 那么它就会根据value属性的值来决定是返回value的值还是抛出异
常, 如果_exception为默认值, 它会设置greenlet属性为当前的协程对象,接着就
会切换到hub协程.</li>
<li>switch: 实际就是调用Waiter对象的greenlet属性的switch方法, 这样就切换到
了对应的协程. 一般会注册到某个watcher的回调函数. 如果greenlet属性为
None,那么意味着switch在get之前运行了,那么就简单的设置下value以
及_exception属性.</li>
</ol>
<p>
<b>需要等待的协程调用get方法,这样该协程就会挂起, 其他的协程调用switch方法切换
到因等待而挂起的协程</b>, 我们来看看Waiter的一个使用例子, Hub的wait方法的代
码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Hub</span><span style="color: #DCDCCC;">(</span>greenlet<span style="color: #DCDCCC;">)</span>:
    ...
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">wait</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, watcher<span style="color: #DCDCCC;">)</span>:
        <span style="color: #DFAF8F;">waiter</span> = Waiter<span style="color: #DCDCCC;">()</span>
        <span style="color: #DFAF8F;">unique</span> = <span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">()</span>
        watcher.start<span style="color: #DCDCCC;">(</span>waiter.switch, unique<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #DFAF8F;">result</span> = waiter.get<span style="color: #DCDCCC;">()</span>
            <span style="color: #F0DFAF; font-weight: bold;">assert</span> result <span style="color: #F0DFAF; font-weight: bold;">is</span> unique, <span style="color: #CC9393;">'Invalid switch into %s: %r (expected %r)'</span> % <span style="color: #DCDCCC;">(</span>getcurrent<span style="color: #BFEBBF;">()</span>, result, unique<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">finally</span>:
            watcher.stop<span style="color: #DCDCCC;">()</span>
    ...
</pre>
</div>
<p>
<b>wait方法的作用是挂起当前的协程,直到watcher监听的事件就绪</b>.它创建一个
Waiter实例waiter,接着将waiter的switch方法注册到wacher上,这样当watcher监听的
事件就绪后就会调用实例的switch方法,接着就调用waiter的get方法, 根据watcher监
听的事件就绪的快慢,这里有两种可能:
</p>
<ol class="org-ol">
<li><b>get在switch之前运行</b>: get会设置waiter的greenlet属性为当前执行的协程, 接着
切换到hub, 当将来某个时候事件就绪,那么调用waiter的switch,switch会调用
greenlet属性的switch方法,这样就切换回了当前运行的协程.</li>
<li><b>get在switch之后运行</b>: 这种情况比较少见,可是也是存在的, 这种情况下运行
switch时,waiter对象的greenlet属性为None, 所以switch方法只是简单的设置
waiter的value属性, 接着调用get会直接返回value属性,而不阻塞.注意不要弄
混_NONE与None.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">Greenlet</h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
这也是一个greenlet的子类,它也是用来产生协程的, 我们先来看看我们创建协程时常
用的spawn函数的源码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Greenlet</span><span style="color: #DCDCCC;">(</span>greenlet<span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, run=<span style="color: #BFEBBF;">None</span>, *args, **kwargs<span style="color: #DCDCCC;">)</span>:
        <span style="color: #DFAF8F;">hub</span> = get_hub<span style="color: #DCDCCC;">()</span>
        greenlet.__init__<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, parent=hub<span style="color: #DCDCCC;">)</span>

    <span style="color: #7CB8BB;">@classmethod</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">spawn</span><span style="color: #DCDCCC;">(</span>cls, *args, **kwargs<span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""Return a new :class:`Greenlet` object, scheduled to start.</span>
<span style="color: #CC9393;">        The arguments are passed to :meth:`Greenlet.__init__`.</span>
<span style="color: #CC9393;">        """</span>
        <span style="color: #DFAF8F;">g</span> = cls<span style="color: #DCDCCC;">(</span>*args, **kwargs<span style="color: #DCDCCC;">)</span>
        g.start<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> g
</pre>
</div>
<p>
gevent.spawn实际就是Greenlet类的spawn方法,该方法直接创建一个Greenlet实例,注
意该实例的parent是hub,而不是默认的主协程, 这样的用处是当协程完成退出时,程序
会继续执行hub的事件循环.然后调用实例的start方法, 下面看看start方法的代码
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">start</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #CC9393;">"""Schedule the greenlet to run in this loop iteration"""</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>._start_event <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._start_event = <span style="color: #F0DFAF; font-weight: bold;">self</span>.parent.loop.run_callback<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.switch<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
start方法实际上就是把该实例丢到hub协程的循环当中,也就是说这个新建的协程就可
以被hub调度了.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">run_callback</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, func, *args<span style="color: #DCDCCC;">)</span>:
    CHECK_LOOP2<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>
    cdef callback <span style="color: #DFAF8F;">cb</span> = callback<span style="color: #DCDCCC;">(</span>func, args<span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">self</span>._callbacks.append<span style="color: #DCDCCC;">(</span>cb<span style="color: #DCDCCC;">)</span>
    libev.ev_ref<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>._ptr<span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> cb
</pre>
</div>
<p>
上面的代码先创建一个callback实例cb,接着将这个实例放进_callbacks列表中, 在core
部分我们分析了_callbacks列表的所有callback实例都会被_prepare watcher的回调
函数 <code>gevent_run_callbacks</code> 运行, 这样实际就是启动了协程.
</p>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">socket模块</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
我们知道为了发挥协程的威力, 我们不能使用标准socket库,必须使用gevent实现的
socket库, 现在我们来分析一下gevent的socket模块,看看该模块是如何使用协程的,
我这里以socket的recv方法为例. 假设调用recv方法的协程为gr.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">socket</span><span style="color: #DCDCCC;">(</span><span style="color: #DCDCCC; font-weight: bold;">object</span><span style="color: #DCDCCC;">)</span>:

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, family=AF_INET, <span style="color: #DCDCCC; font-weight: bold;">type</span>=SOCK_STREAM, proto=<span style="color: #BFEBBF;">0</span>, _sock=<span style="color: #BFEBBF;">None</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> _sock <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
            <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock = _realsocket<span style="color: #DCDCCC;">(</span>family, <span style="color: #DCDCCC; font-weight: bold;">type</span>, proto<span style="color: #DCDCCC;">)</span>
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout = _socket.getdefaulttimeout<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">hasattr</span><span style="color: #DCDCCC;">(</span>_sock, <span style="color: #CC9393;">'_sock'</span><span style="color: #DCDCCC;">)</span>:
                <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock = _sock._sock
                <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout = <span style="color: #DCDCCC; font-weight: bold;">getattr</span><span style="color: #DCDCCC;">(</span>_sock, <span style="color: #CC9393;">'timeout'</span>, <span style="color: #BFEBBF;">False</span><span style="color: #DCDCCC;">)</span>
                <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">False</span>:
                    <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout = _socket.getdefaulttimeout<span style="color: #DCDCCC;">()</span>
            <span style="color: #F0DFAF; font-weight: bold;">else</span>:
                <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock = _sock
                <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout = _socket.getdefaulttimeout<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock.setblocking<span style="color: #DCDCCC;">(</span><span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">)</span>
        <span style="color: #DFAF8F;">fileno</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock.fileno<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub = get_hub<span style="color: #DCDCCC;">()</span>
        <span style="color: #DFAF8F;">io</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub.loop.io
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._read_event = io<span style="color: #DCDCCC;">(</span>fileno, <span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._write_event = io<span style="color: #DCDCCC;">(</span>fileno, <span style="color: #BFEBBF;">2</span><span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
__init__很简单,创建一个socket(self._sock),将该描述符设置为非阻塞,同时创建两个
watcher,分别监听读事件(self._read_event)以及写事件(self._write_event),下面
看看recv的代码:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">recv</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, *args<span style="color: #DCDCCC;">)</span>:
    <span style="color: #DFAF8F;">sock</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>._sock  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">keeping the reference so that fd is not closed during waiting</span>
    <span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #BFEBBF;">True</span>:
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #F0DFAF; font-weight: bold;">return</span> sock.recv<span style="color: #DCDCCC;">(</span>*args<span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">except</span> error:
            <span style="color: #DFAF8F;">ex</span> = sys.exc_info<span style="color: #DCDCCC;">()[</span><span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">]</span>
            <span style="color: #F0DFAF; font-weight: bold;">if</span> ex.args<span style="color: #DCDCCC;">[</span><span style="color: #BFEBBF;">0</span><span style="color: #DCDCCC;">]</span> != EWOULDBLOCK <span style="color: #F0DFAF; font-weight: bold;">or</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout == <span style="color: #BFEBBF;">0</span>.<span style="color: #BFEBBF;">0</span>:
                <span style="color: #F0DFAF; font-weight: bold;">raise</span>
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">QQQ without clearing exc_info test__refcount.test_clean_exit fails</span>
            sys.exc_clear<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>._wait<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>._read_event<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
recv直接调用内置模块的recv方法,如果发现该调用会阻塞,那么就调用_wait方法, 该
方法也是代码的关键部分.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">_wait</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, watcher, timeout_exc=timeout<span style="color: #BFEBBF;">(</span><span style="color: #CC9393;">'timed out'</span><span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #CC9393;">"""Block the current greenlet until *watcher* has pending events.</span>

<span style="color: #CC9393;">    If *timeout* is non-negative, then *timeout_exc* is raised after *timeout* second has passed.</span>
<span style="color: #CC9393;">    By default *timeout_exc* is ``socket.timeout('timed out')``.</span>

<span style="color: #CC9393;">    If :func:`cancel_wait` is called, raise ``socket.error(EBADF, 'File descriptor was closed in another greenlet')``.</span>
<span style="color: #CC9393;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> watcher.callback <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>, <span style="color: #CC9393;">'This socket is already used by another greenlet: %r'</span> % <span style="color: #DCDCCC;">(</span>watcher.callback, <span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #BFEBBF;">None</span>:
        <span style="color: #DFAF8F;">timeout</span> = Timeout.start_new<span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.timeout, timeout_exc, ref=<span style="color: #BFEBBF;">False</span><span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">else</span>:
        <span style="color: #DFAF8F;">timeout</span> = <span style="color: #BFEBBF;">None</span>
    <span style="color: #F0DFAF; font-weight: bold;">try</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub.wait<span style="color: #DCDCCC;">(</span>watcher<span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">finally</span>:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> timeout <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #BFEBBF;">None</span>:
            timeout.cancel<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
根据注释我们知道_wait方法会使当前的协程暂停,直到watcher监听的事件就绪. 代码的
关键部分是 <code>self.hub.wait(watcher)</code>, 这个方法在上面已经分析过,只要明白它会阻
塞当前的协程切换到hub协程, 而如果watcher监听的事件就绪,它又会切换会当前协程,
在recv的例子中,一旦wacher监听的事件就绪也就意味着socket已经处于读就绪状态,所
以也就可以调用内置的socket模块的recv方法来获得数据了.
</p>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">timeout模块</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
该模块实现了一个超时机制, 它先挂起当前的协程, 当指定的时间到了之后,它会切换
到该协程,并且在该协程中抛出异常. 这样就实现了挂起协程的目的
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Timeout</span><span style="color: #DCDCCC;">(</span><span style="color: #7CB8BB;">BaseException</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">__init__</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>, seconds=<span style="color: #BFEBBF;">None</span>, exception=<span style="color: #BFEBBF;">None</span>, ref=<span style="color: #BFEBBF;">True</span>, priority=-<span style="color: #BFEBBF;">1</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.seconds = seconds
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.exception = exception
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer = get_hub<span style="color: #DCDCCC;">()</span>.loop.timer<span style="color: #DCDCCC;">(</span>seconds <span style="color: #F0DFAF; font-weight: bold;">or</span> <span style="color: #BFEBBF;">0</span>.<span style="color: #BFEBBF;">0</span>, ref=ref, priority=priority<span style="color: #DCDCCC;">)</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">start</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""Schedule the timeout."""</span>
        <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.pending, <span style="color: #CC9393;">'%r is already started; to restart it, cancel it first'</span> % <span style="color: #F0DFAF; font-weight: bold;">self</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.seconds <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">"fake" timeout (never expires)</span>
            <span style="color: #F0DFAF; font-weight: bold;">pass</span>
        <span style="color: #F0DFAF; font-weight: bold;">elif</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.exception <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span> <span style="color: #F0DFAF; font-weight: bold;">or</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.exception <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">False</span> <span style="color: #F0DFAF; font-weight: bold;">or</span> <span style="color: #DCDCCC; font-weight: bold;">isinstance</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span>.exception, string_types<span style="color: #DCDCCC;">)</span>:
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timeout that raises self</span>
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer.start<span style="color: #DCDCCC;">(</span>getcurrent<span style="color: #BFEBBF;">()</span>.throw, <span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">regular timeout with user-provided exception</span>
            <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer.start<span style="color: #DCDCCC;">(</span>getcurrent<span style="color: #BFEBBF;">()</span>.throw, <span style="color: #F0DFAF; font-weight: bold;">self</span>.exception<span style="color: #DCDCCC;">)</span>

    <span style="color: #7CB8BB;">@classmethod</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">start_new</span><span style="color: #DCDCCC;">(</span>cls, timeout=<span style="color: #BFEBBF;">None</span>, exception=<span style="color: #BFEBBF;">None</span>, ref=<span style="color: #BFEBBF;">True</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">isinstance</span><span style="color: #DCDCCC;">(</span>timeout, Timeout<span style="color: #DCDCCC;">)</span>:
            <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> timeout.pending:
                timeout.start<span style="color: #DCDCCC;">()</span>
            <span style="color: #F0DFAF; font-weight: bold;">return</span> timeout
        <span style="color: #DFAF8F;">timeout</span> = cls<span style="color: #DCDCCC;">(</span>timeout, exception, ref=ref<span style="color: #DCDCCC;">)</span>
        timeout.start<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> timeout

    <span style="color: #7CB8BB;">@property</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">pending</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""Return True if the timeout is scheduled to be raised."""</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer.pending <span style="color: #F0DFAF; font-weight: bold;">or</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer.active

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">cancel</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">self</span><span style="color: #DCDCCC;">)</span>:
        <span style="color: #CC9393;">"""If the timeout is pending, cancel it. Otherwise, do nothing."""</span>
        <span style="color: #F0DFAF; font-weight: bold;">self</span>.timer.stop<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
先看__init__, 它为实例创建了如下属性:
</p>
<ol class="org-ol">
<li>seconds: 超时的秒数, 如果为None,那么永不超时</li>
<li>exception: 超时抛出的异常,如果为None,那么就抛出self本身</li>
<li>timer: 一个timer watcher</li>
</ol>
<p>
在来看start, 它分为三种情况:
</p>
<ol class="org-ol">
<li>self.second为None: 那么直接pass, 这就意味者timer没有注册到时间循环中,所
以也就永远不会超时</li>
<li>self.exception为None: 它会将 <code>getcurrent().throw</code> 注册为timer的回调函数,
我们知道协程对象的throw方法和switch是相似的,都会切换到对应协程,只是throw
在切换到对应协程后会立刻将它的参数作为异常抛出, 所以一旦超时,那么就会切
换到当前协程,然后抛出self</li>
<li>self.exception不为None, 和2相似,只是超时会抛出self.exception而不是self本
身.</li>
</ol>
<p>
start_new是一个包装函数, 正常情况下你要先创建一个timeout实例,然后调用该实例
的start方法, 现在你只需要调用这个方法它就会把这两步一起搞定.
</p>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">timeout使用指南</h4>
<div class="outline-text-4" id="text-orgheadline17">
<p>
一般情况下timeout都是这样使用的
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">timeout</span> = Timeout<span style="color: #DCDCCC;">(</span>seconds, exception<span style="color: #DCDCCC;">)</span>
timeout.start<span style="color: #DCDCCC;">()</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span>:
    ...  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">exception will be raised here, after *seconds* passed since start() call</span>
<span style="color: #F0DFAF; font-weight: bold;">finally</span>:
    timeout.cancel<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
最开始的两行可以用Timeout.start_new代替, 在try中间我们一般会切换到其它的协
程, 当超时后会自动切换回来,并且抛出异常,这样try就可以捕捉到了.来看看一个更
具体的例子,event.py中的例子:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #DFAF8F;">timer</span> = Timeout.start_new<span style="color: #DCDCCC;">(</span>timeout<span style="color: #DCDCCC;">)</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span>:
    <span style="color: #F0DFAF; font-weight: bold;">try</span>:
        <span style="color: #DFAF8F;">result</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.hub.switch<span style="color: #DCDCCC;">()</span>
        <span style="color: #F0DFAF; font-weight: bold;">assert</span> result <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>, <span style="color: #CC9393;">'Invalid switch into Event.wait(): %r'</span> % <span style="color: #DCDCCC;">(</span>result, <span style="color: #DCDCCC;">)</span>
    <span style="color: #F0DFAF; font-weight: bold;">except</span> Timeout <span style="color: #F0DFAF; font-weight: bold;">as</span> ex:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> ex <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> timer:
            <span style="color: #F0DFAF; font-weight: bold;">raise</span>
<span style="color: #F0DFAF; font-weight: bold;">finally</span>:
    timer.cancel<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
很显然的例子.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">Event</h3>
<div class="outline-text-3" id="text-orgheadline18">
<p>
该模块的Event实现了协程间的通知机制, 也就是一个协程可以唤醒监听该event的所
有协程.
</p>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19">Event使用指南</h4>
<div class="outline-text-4" id="text-orgheadline19">
<p>
在一个协程中创建event对象,并调用该对象的wait方法,这样该协程就会阻塞,直到另
外一个协程调用了该event对象的set方法,代码如下:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">greenlet1</span>
<span style="color: #DFAF8F;">evt</span> = Event<span style="color: #DCDCCC;">()</span>
evt.wait<span style="color: #DCDCCC;">()</span>                <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">block until other greenlets invoke evt.set()</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">greenlet2</span>
evt.<span style="color: #DCDCCC; font-weight: bold;">set</span><span style="color: #DCDCCC;">()</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">AsycResult</h3>
</div>
<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">queue</h3>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">channel</h3>
<div class="outline-text-3" id="text-orgheadline23">
</div><div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">channel使用指南</h4>
<div class="outline-text-4" id="text-orgheadline22">
<p>
和go语言的channel类似,只是没有缓存也没有类型信息,如果要缓存,那么可能queue
更合适
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">greenlet1</span>
<span style="color: #DFAF8F;">chan</span> = Channel<span style="color: #DCDCCC;">()</span>
<span style="color: #DFAF8F;">val</span> = chan.get<span style="color: #DCDCCC;">()</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">greenlet2</span>
chan.put<span style="color: #DCDCCC;">(</span>val<span style="color: #DCDCCC;">)</span>
</pre>
</div>
<p>
使用方法也是两个协程配合, 一个读一个写,如果channel未就绪,那么相应的读或者
写就会阻塞执行该操作的的这个协程.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">其它</h3>
<div class="outline-text-3" id="text-orgheadline24">
<p>
在Greenlet类的join函数中有如下代码：
</p>
<div class="org-src-container">

<pre class="src src-python"><span class="linenr">1: </span><span style="color: #DFAF8F;">switch</span> = getcurrent<span style="color: #DCDCCC;">()</span>.switch
<span class="linenr">2: </span><span style="color: #F0DFAF; font-weight: bold;">self</span>.rawlink<span style="color: #DCDCCC;">(</span>switch<span style="color: #DCDCCC;">)</span>
<span class="linenr">3: </span>
<span class="linenr">4: </span><span style="color: #DFAF8F;">result</span> = <span style="color: #F0DFAF; font-weight: bold;">self</span>.parent.switch<span style="color: #DCDCCC;">()</span>
</pre>
</div>
<p>
rawlink的作用是注册一个函数，这个函数会在这个greenlet运行完成后调用
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-2">
<h2 id="orgheadline25">第三方库</h2>
<div class="outline-text-2" id="text-orgheadline25">
<p>
gevent不像go一样是官方内置的，所以有些时候和第三方库配合会有一些问题，总的来说
python写成的库可以直接monkey patch，C写成的库可以直接用豆瓣开源的greenify来打
patch。
</p>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">greenify</h3>
<div class="outline-text-3" id="text-orgheadline26">
<p>
这个库可以将C扩展打patch，这样可以让他们兼容gevent，它直接工作于二进制文件这一级，
不需要你修改C扩展代码，目前只支持ELF文件格式。他会自动的对网络相关的代码来patch。
</p>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">PyMongo</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
有几个注意事项。
</p>
<ol class="org-ol">
<li>只初始化一个 <code>pymongo.Connection</code> 对象，最好把这个弄成一个模块级或者全局变量，
库的内部由pool，所以你不用操心。</li>
<li>至少要monkey patch掉socket和threading模块</li>
<li>要调用 <code>end_request</code> 来将连接归还到pool中。</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_comment">
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        var url_path = window.location.pathname;
        var disqus_identifier = url_path.substring(url_path.lastIndexOf('/')+1);

        this.page.url = window.location.href;
        this.page.identifier = disqus_identifier;
        // this.page.title = document.title;
    };

    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');

        s.src = '//yuyang.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
<!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>
