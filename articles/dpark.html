<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-06-22 五 12:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dpark</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Yu Yang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="static/css/main.css"/>
<link rel="shortcut icon" href="static/img/favicon.ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">
      <div class="inner">
        <h1 id="site-title"><a href="/"> 编码者言 </a></h1>
        <div>
          <a href="###" id="site-nav-btn">菜单</a>
          <ul id="site-nav" class="vertical-nav mobi-hid">
            <li> <a href="/">Home</a></li>
            <li> <a href="/about.html">About</a></li>

            <li> <a href="/tags.html">Tags</a></li>

            <li> <a href="/atom.xml">RSS</a></li>
          </ul>

          <form id="site-search" method="get" action="https://google.com/search">
            <input type="hidden" name="q" value="site:yuyang0.github.io" />
            <input type="text" name="q" placeholder="Search..." />
            <button class="btn-search" type="submit">Search</button>
          </form>
          <div style="clear:both;"> </div>
        </div>
      </div>
    </div>
</div>
<div id="content">
<h1 class="title">Dpark</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5cd6ac3">Big Picture</a></li>
<li><a href="#org9d9ad19">RDD</a>
<ul>
<li><a href="#org24ee80d">Transformations</a></li>
<li><a href="#org9609b13">Actions</a></li>
<li><a href="#orgd68b51a">Dependency</a>
<ul>
<li><a href="#org4ecc47b">Narrow Dependency</a></li>
<li><a href="#orgc92a284">Wide Dependency</a></li>
</ul>
</li>
<li><a href="#org0a47dff">Partitioner</a></li>
<li><a href="#orge7aef30">Aggregator</a></li>
<li><a href="#org45d2c77">Merger</a></li>
<li><a href="#orgfbb92f9">RDD</a></li>
</ul>
</li>
<li><a href="#org0e94254">Context(context.py)</a>
<ul>
<li><a href="#orgafb7173">DparkContext</a></li>
<li><a href="#orge21fea3">命令行参数</a></li>
</ul>
</li>
<li><a href="#org9bd9494">cache(cache.py)</a>
<ul>
<li><a href="#org50a2ed3">Cache</a></li>
<li><a href="#org7ef1990">DiskCache</a></li>
<li><a href="#org8f27f27">CacheTracker</a></li>
</ul>
</li>
<li><a href="#org159594f">Tracker(tracker.py)</a>
<ul>
<li><a href="#orgb94c915">消息类型</a></li>
</ul>
</li>
<li><a href="#org912fa3b">shuffle</a></li>
<li><a href="#orgfac45ce">env(env.py)</a></li>
<li><a href="#org218a3cf">conf(conf.py)</a></li>
<li><a href="#orge23c130">调度系统</a>
<ul>
<li><a href="#org1b77a2a">基本概念</a></li>
<li><a href="#orgb96e2d2">Stage</a></li>
<li><a href="#org6466aba">DAGScheduler</a></li>
<li><a href="#org7015826">MesosScheduler</a></li>
<li><a href="#org4826ebd">Task(task.py)</a></li>
</ul>
</li>
<li><a href="#org9ec1de1">Executor(executor.py)</a>
<ul>
<li><a href="#org2b0c9e0">web server</a></li>
<li><a href="#org05c3bc6">进程池</a></li>
<li><a href="#org0a9834a">run_task</a></li>
<li><a href="#org705e1ff">MyExecutor</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5cd6ac3" class="outline-2">
<h2 id="org5cd6ac3">Big Picture</h2>
<div class="outline-text-2" id="text-org5cd6ac3">
<p>
dpark的计算过程是这样的：
</p>
<ol class="org-ol">
<li>先创建第一个RDD，这是通过Context类的textFile，CSVFile这类调用实现的，</li>
<li>接着在这个rdd调用一系列的transformation.</li>
<li>最后调用一个operation，调用operation才会触发真正的运算, 因为这类操作运算一般
都会调用Context对象的runJob方法，</li>
<li>Context的runJob方法会执行如下动作：
<ul class="org-ul">
<li>调用Context的start方法，该方法会初始化env，scheduler,</li>
<li>调用scheduler的runJob方法，该方法就会根据你指定的运行模式(local,process,
mesos)来运行。</li>
<li>将scheduler的runJob的返回值(一般rdd的一个分区对应一个值) yield 出来。</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org9d9ad19" class="outline-2">
<h2 id="org9d9ad19">RDD</h2>
<div class="outline-text-2" id="text-org9d9ad19">
<p>
RDD可以理解为一个集合.
</p>
</div>
<div id="outline-container-org24ee80d" class="outline-3">
<h3 id="org24ee80d">Transformations</h3>
<div class="outline-text-3" id="text-org24ee80d">
<ol class="org-ol">
<li><p>
groupBy: 先通过map得到key，然后reduceByKey
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">self</span>.<span style="color: #DCDCCC; font-weight: bold;">map</span><span style="color: #DCDCCC;">(</span><span style="color: #F0DFAF; font-weight: bold;">lambda</span> x: <span style="color: #BFEBBF;">(</span>f<span style="color: #D0BF8F;">(</span>x<span style="color: #D0BF8F;">)</span>, x<span style="color: #BFEBBF;">)</span><span style="color: #DCDCCC;">)</span>.reduceByKey<span style="color: #DCDCCC;">()</span>
</pre>
</div></li>
<li>pipe: 将分区丢给一个shell命令运行, 将结果返回</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-org9609b13" class="outline-3">
<h3 id="org9609b13">Actions</h3>
<div class="outline-text-3" id="text-org9609b13">
<p>
dpark上的计算是惰性的，当你调用一系列的transformation时，计算并没有真正触发，只
有调用Action时才真正触发运算，常用的Action如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">count</td>
<td class="org-left">获得元素个数</td>
</tr>

<tr>
<td class="org-left">collect</td>
<td class="org-left">返回元素列表</td>
</tr>

<tr>
<td class="org-left">first</td>
<td class="org-left">返回第一个元素</td>
</tr>

<tr>
<td class="org-left">reduce</td>
<td class="org-left">归约</td>
</tr>

<tr>
<td class="org-left">saveAsTextFile</td>
<td class="org-left">保存为文件</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgd68b51a" class="outline-3">
<h3 id="orgd68b51a">Dependency</h3>
<div class="outline-text-3" id="text-orgd68b51a">
</div>
<div id="outline-container-org4ecc47b" class="outline-4">
<h4 id="org4ecc47b">Narrow Dependency</h4>
<div class="outline-text-4" id="text-org4ecc47b">
<p>
父RDD的一个分区最多只被子RDD的一个分区所依赖，为了实现方便，他又分为两种类型：
</p>
<ol class="org-ol">
<li>一对一：子RDD的一个分区只依赖父RDD的一个分区</li>
<li>一对多：也就是说子RDD的一个分区依赖父RDD的多个分区</li>
</ol>

<p>
<b>实现</b>: 都有一个getParents方法,给定子rdd的一个分区编号获得依赖的父分区编号.注意
 返回的是一个列表.
</p>
<ol class="org-ol">
<li>OneToOneDependency: 子rdd与父rdd有相同的分区编号(pid)</li>
<li>OneToRangeDependency: 子rdd一个分区对应于父rdd的多个分区,注意splitSize指的是
子rdd一个分区对应父rdd的分区的个数,不是指分区的元素个数,同时length也是指父rdd
分区的个数.</li>
<li>CartesianDependency: 笛卡尔积，通过cartesian(rdd1, rdd2)运算后得到的rdd它的分
区数是rdd1的分区数乘以rdd2的分区数，所以结果rdd中的一个分区实际只依赖rdd1中的
一个分区，以及rdd2中的一个分区。</li>
<li>RangeDependency: 比如子rdd的第10~20分区依赖父rdd的1~11分区,也就是说分区是一一
对应的,只是有多个分区,其实我们可以把这种依赖拆成length个OneToOneDependency</li>
</ol>
</div>
</div>
<div id="outline-container-orgc92a284" class="outline-4">
<h4 id="orgc92a284">Wide Dependency</h4>
<div class="outline-text-4" id="text-orgc92a284">
<p>
父RDD的一个分区被子RDD的多个分区所依赖，这种依赖意味着为了计算子RDD的一个分区，
我们必须进行shuffle操作。shuffle对性能的影响很大。
</p>
<ol class="org-ol">
<li>shuffleDependency: 一个id, 父rdd, aggregator, partitioner</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0a47dff" class="outline-3">
<h3 id="org0a47dff">Partitioner</h3>
<div class="outline-text-3" id="text-org0a47dff">
<p>
返回分区的相关的信息 <b>接口</b>:
</p>
<ol class="org-ol">
<li>numPartitions: 获得分区数量</li>
<li>getPartition: 获得分区编号, 一个父rdd中的key应该放在现rdd的哪个split由这个函
数决定。</li>
</ol>
<p>
分区有两种类型：
</p>
<ol class="org-ol">
<li>HashPartitioner：也就是说rdd中元素是根据hash值来分区的, 初始化时，你需要传入
分区的个数, 要获得分区编号时实际是将hash值与分区个数取模</li>
<li>RangePartitioner：rdd中的元素都是使用排序来分区，所以可以使用二分法来确定某个
给定元素所在的分区, 在初始化时你必须传入标示分区开始和结尾的key所组成的list,
在获得分区编号时是使用二分查找.</li>
</ol>
</div>
</div>
<div id="outline-container-orge7aef30" class="outline-3">
<h3 id="orge7aef30">Aggregator</h3>
<div class="outline-text-3" id="text-orge7aef30">
<p>
聚合器，实际上指定了如何把多个值聚合起来, 实现实际上包含三个函数：
</p>
<ol class="org-ol">
<li>createCombiner： 如何根据一个值来创建一个combiner</li>
<li>mergeValue： 如何将一个值添加到一个combiner中</li>
<li>mergeCombiner： 将两个combiner合并</li>
</ol>
<p>
combiner可以是整数(AddAggregator),列表(MergeAggregator), 可以是
set(UniqAggregator), 还可以是其它的容器类型,这个东西主要是用在shuffle中,当产
生值之后如何把它们合并到一起, 不同的需求需要不同的合并方式.
</p>
</div>
</div>
<div id="outline-container-org45d2c77" class="outline-3">
<h3 id="org45d2c77">Merger</h3>
<div class="outline-text-3" id="text-org45d2c77">
<p>
合并K/V键值对
</p>
<ol class="org-ol">
<li>Merger: 内部有一个字典属性(combined)以及一个mergeCombiner(用来合并相同键
对应的值),有一个merge方法,调用该方法会将你传入的字典合并到内部的字典属性
上,如果一个键上有多个值,那么调用mergeCombiner来合并</li>
</ol>
</div>
</div>
<div id="outline-container-orgfbb92f9" class="outline-3">
<h3 id="orgfbb92f9">RDD</h3>
<div class="outline-text-3" id="text-orgfbb92f9">
<p>
这个类是用来描述rdd的，它有很多子类, 这些类都有以下几个比较重要的属性和方法:
</p>
<ol class="org-ol">
<li>iterator: 最终实际上返回的是compute的结果，只是会先到snapshot或者cache中找。
找不到就调用compute生成。</li>
<li>compute：根据rdd的类型确定如何根据父rdd来计算本rdd。一般是返回一个生成器或者
可迭代对象。</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0e94254" class="outline-2">
<h2 id="org0e94254">Context(context.py)</h2>
<div class="outline-text-2" id="text-org0e94254">
</div>
<div id="outline-container-orgafb7173" class="outline-3">
<h3 id="orgafb7173">DparkContext</h3>
<div class="outline-text-3" id="text-orgafb7173">
<p>
DparkContext类中中有几个非常重要的方法:
</p>
<ol class="org-ol">
<li>init: 实际根据运行模式插创建scheduler属性</li>
<li>start: 调用init方法,接着调用env的start方法</li>
<li>runJob: 调用start方法, 接着调用scheduler属性的runJob方法,这个方法实际就会进行实际的运行过程. 这个方法一般会被RDD的operation触发.</li>
</ol>
</div>
</div>
<div id="outline-container-orge21fea3" class="outline-3">
<h3 id="orge21fea3">命令行参数</h3>
<div class="outline-text-3" id="text-orge21fea3">
<p>
add_default_options, parse_options都是用来获取命令行参数的。命令行参数有以下几个：
</p>
<ul class="org-ul">
<li>master: 运行模式，默认local</li>
<li>self： 是不是将该脚本本身作为executor，默认为None(如果该参数为None，那么默认为executor.py)</li>
<li>cpus：一个task占用的cpu核数, 默认为1</li>
<li>mem： 一个task占用的内存，默认为None</li>
<li>snapshot_dir: 存储rdd的snapshot的dir，默认为""</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9bd9494" class="outline-2">
<h2 id="org9bd9494">cache(cache.py)</h2>
<div class="outline-text-2" id="text-org9bd9494">
<p>
缓存相关
</p>
</div>
<div id="outline-container-org50a2ed3" class="outline-3">
<h3 id="org50a2ed3">Cache</h3>
<div class="outline-text-3" id="text-org50a2ed3">
<p>
实际是对字典的一层包装, 提供get, put, clear三个方法.
</p>
</div>
</div>
<div id="outline-container-org7ef1990" class="outline-3">
<h3 id="org7ef1990">DiskCache</h3>
<div class="outline-text-3" id="text-org7ef1990">
<p>
文件cache，将rdd的每一个分区保存为一个文件$(WORK_DIR)/cache/rddId_splitId.pid
</p>
<ul class="org-ul">
<li>get</li>
<li>put</li>
<li>save</li>
<li>load</li>
</ul>
</div>
</div>
<div id="outline-container-org8f27f27" class="outline-3">
<h3 id="org8f27f27">CacheTracker</h3>
<div class="outline-text-3" id="text-org8f27f27">
<p>
它内部有一个DiskCache对象，也就是用来缓存rdd的分区计算结果的。每一个split缓存在
哪个host都是会保存到TrackerServer上的。{“cache:rddIdx-splitIdx": hostname}
</p>
<ul class="org-ul">
<li>getOrCompute: 缓存上有，那么就返回缓存上的结果，如果没有那就是用compute来计算。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org159594f" class="outline-2">
<h2 id="org159594f">Tracker(tracker.py)</h2>
<div class="outline-text-2" id="text-org159594f">
<p>
实际上是使用zmq实现的一个服务器与客户端, 这个服务器会跟踪整个系统的信息，比如每
个rdd的split的缓存节点的url，shuffle的相关信息等等。像CacheTracker，
MapOutputTracker都需要和TrackServer进行交互。
</p>
<ol class="org-ol">
<li>TrackerServer: 服务器,内部有一个locs字典, 该字典的value都是列表,这个server
会接受客户端的消息,然后根据消息类型向locs字典添加,删除,修改等操作或者终止
服务器.</li>
<li>TrackerClient: 客户端实现, 主要是一个call方法可以向服务端发送消息</li>
</ol>
</div>
<div id="outline-container-orgb94c915" class="outline-3">
<h3 id="orgb94c915">消息类型</h3>
<div class="outline-text-3" id="text-orgb94c915">
<ol class="org-ol">
<li><p>
SetValueMessage: 设置key所对应的值,注意值必须为列表
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #DCDCCC; font-weight: bold;">isinstance</span><span style="color: #DCDCCC;">(</span>value, <span style="color: #DCDCCC; font-weight: bold;">list</span><span style="color: #DCDCCC;">)</span>:
    <span style="color: #DFAF8F;">value</span> = <span style="color: #DCDCCC;">[</span>value<span style="color: #DCDCCC;">]</span>

<span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span> = value
</pre>
</div></li>
<li><p>
AddItemMessage: 向key所对应的值列表中添加一个值
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> key <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs:
    <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span> = <span style="color: #DCDCCC;">[]</span>

<span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>.append<span style="color: #DCDCCC;">(</span>item<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
RemoveItemMessage: 从key所对应的值列表中移除item
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">if</span> item <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>:
    <span style="color: #F0DFAF; font-weight: bold;">self</span>.locs<span style="color: #DCDCCC;">[</span>key<span style="color: #DCDCCC;">]</span>.remove<span style="color: #DCDCCC;">(</span>item<span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li><p>
GetValueMessage: 返回和key绑定的值列表
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">self</span>.locs.get<span style="color: #DCDCCC;">(</span>key, <span style="color: #BFEBBF;">[]</span><span style="color: #DCDCCC;">)</span>
</pre>
</div></li>
<li>StopTrackerMessage: 通知服务器退出.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org912fa3b" class="outline-2">
<h2 id="org912fa3b">shuffle</h2>
<div class="outline-text-2" id="text-org912fa3b">
<p>
因为宽依赖的关系，rdd的一个split的数据可能分布在多个不同机器上，所以必须通过
shuffle来重组，实际上宽依赖的计算是这样进行的：
</p>
<ol class="org-ol">
<li>父rdd的每一个split根据partitioner被拆成多个bucket，每一个bucket就保存为一个文
件, 实际上bucket和split是对应的，例如bucket 1就保存着split 1中的一部分元素，
split 1的剩余元素在其它节点的bucket 1中</li>
<li>将分布再多个节点的bucket合并成split，假设有A，B，C三个节点保存了rdd的 信息，
那么要获得split 1，那么就要拿到A，B，C上的bucket 1，将三者合并，split 2类似。</li>
</ol>
<p>
shuffle.py文件主要有这样几个属性：
</p>
<ol class="org-ol">
<li>MapOutputTracker: 用来跟踪shuffleId与该shuffle的输出的，内部实际上是一个
TrackerClient实例，它会和TrackerServer通信,它有两个方法:
<ul class="org-ul">
<li>registerMapOutputs: 将shuffleId与locs绑定.</li>
<li>getServerUris:　根据shuffleID得到所有的locs</li>
</ul></li>
<li>SimpleShuffleFetcher:　实际就是通过urlopen来获得数据块
<ul class="org-ul">
<li><p>
fetch_one: 根据uri来下载数据,数据的格式是:
</p>
<ul class="org-ul">
<li>第一个字节:　标志, m 或者p, 指示到底是用marshal还是cPickle序列化数据</li>
<li>2~4个字节:　整个长度, 主要是用来校验数据是否有错误</li>
<li>5~结尾: 数据,需要反序列化.</li>
</ul>
<p>
该方法返回反序列化后的数据
</p></li>
<li>fetch:使用fetch_one获得数据,然后在数据上调用func,func是Merger实例的merge方
法,这个方法会将数据全部合并到Merger实例内部的一个字典属性上</li>
</ul></li>
<li>ParallelShuffleFetcher:和SimpleShuffleFetcher的区别就是会使用多线程下载数据</li>
</ol>
</div>
</div>
<div id="outline-container-orgfac45ce" class="outline-2">
<h2 id="orgfac45ce">env(env.py)</h2>
<div class="outline-text-2" id="text-orgfac45ce">
<p>
实际就是DparkEnv这个类, 内部有一个environ列表:
</p>
<ol class="org-ol">
<li>register:  将一个键值对放入environ列表</li>
<li>get: 获得和一个键绑定的值</li>
<li>start: 进行一些初始化设置
<ul class="org-ul">
<li><p>
设置eviron中的属性,如果是master机器会设置如下的属性:
</p>
<ul class="org-ul">
<li>SERVER_URI: 在master上是一个file url,实际上是<a href="file://WORKDIR">file://WORKDIR</a>[0], 其它节点
上为 <a href="http://hostname%3Aport/workdir_basename">http://hostname:port/workdir_basename</a> , 比如如果一个workdir为
<code>/tmp/dpark/20150827-111925-yy-5488</code>, 那么这个url可能就是
<a href="http://yy:45445/20150827-111925-yy-5488">http://yy:45445/20150827-111925-yy-5488</a>, 这个url很重要，它是节点间获取数
据的途径。除master以外的其它节点都要启动一个web server，这个web server会
跟据请求的url来将WORKDIR[0]中相应的文件返回给客户端，这样cache以及各种中
间计算文件只要放在工作目录，那么其它的节点就可以根据这个url来获得了。</li>
<li>WORKDIR: 一个目录列表,每一个元素是这样的格式, DPARK_WORK_DIR+时间+hostname+进程id</li>
<li>COMPRESS: 压缩函数</li>
</ul>
<p>
如果不是master,那么只设置COMPRESS. 其它的部分比如SERVER_URI会由Scheduler序
列化后传给Executor，然后通过environ来传给start，start会将这些合并到内部d额
字典
</p></li>
<li>创建一个ctx属性, 这是一个zmq的context实例。</li>
<li>如果是master机器,那么会启动一个TrackerServer实例, 所以会有一个trackerServer
属性.</li>
<li>创建一个trackerClinet属性，它是一个TrackerClient实例</li>
<li>创建一个cacheTracker属性，它是一个CacheTracker实例</li>
<li>创建一个mapOutputTracker属性, 它是一个MapOutputTracker实例。</li>
<li>创建一个shuffleFetcher属性, 它是一个ParallelShuffleFetcher实例</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org218a3cf" class="outline-2">
<h2 id="org218a3cf">conf(conf.py)</h2>
<div class="outline-text-2" id="text-org218a3cf">
<ol class="org-ol">
<li>DPARK_WORK_DIR: 工作目录,shuffle等操作都会使用该目录.可能包含多个目录,以逗号
分割</li>
<li>MESOS_MASTER: mesos集群的master地址</li>
<li>MEM_PER_TASK: 这个很重要如果设的太大会使机器启动失败</li>
</ol>
</div>
</div>
<div id="outline-container-orge23c130" class="outline-2">
<h2 id="orge23c130">调度系统</h2>
<div class="outline-text-2" id="text-orge23c130">
</div>
<div id="outline-container-org1b77a2a" class="outline-3">
<h3 id="org1b77a2a">基本概念</h3>
<div class="outline-text-3" id="text-org1b77a2a">
<ol class="org-ol">
<li>partitioner： 获得分区的个数，以及根据你传进去的key来获得分区的下标</li>
<li>job：一个作业实际就是一次Action触发的整个任务</li>
<li>stage：调度系统会根据RDD的血统将整个job切分成多个stage，切分依据主要是
shuffle dependence</li>
<li>task：一次最小的执行过程，一般是对RDD的一个分区进行的操作。</li>
<li>taskSet： 一个stage拆分成得到的多个task组成的一个聚合</li>
</ol>
</div>
</div>
<div id="outline-container-orgb96e2d2" class="outline-3">
<h3 id="orgb96e2d2">Stage</h3>
<div class="outline-text-3" id="text-orgb96e2d2">
<p>
所有的transformation在rdd上最后会形成一个有向无环图(DAG), 所以要把那些能在一台机
器上运行的任务切分出来，dpark就是用stage表示的，注意dpark只在两个地方创建stage，
一个是finalStage，在一个就是遇到shuffleDependence时创建一个stage，stage有如下属性：
</p>
<ol class="org-ol">
<li>shuffleDep： finalStage的该属性为None。</li>
<li>rdd：这个shuffleDep依赖的rdd。</li>
<li>outputLocs: 各个split输出的结果所在的hosts(一个列表)</li>
<li>parents: 该stage的父stage列表。</li>
</ol>
</div>
</div>
<div id="outline-container-org6466aba" class="outline-3">
<h3 id="org6466aba">DAGScheduler</h3>
<div class="outline-text-3" id="text-org6466aba">
<p>
这是一个很核心的类，也就是后面的LocalScheduler，ProcessScheduler，MesosScheduler
都是继承的这个类，下面详细的分析一下这个类：
</p>
<ol class="org-ol">
<li>runJob: 这个方法是被ctx的runJob方法触发的，它的基本流程是这样的：
<ol class="org-ol">
<li>创建一个finalStage</li>
<li>submitStage：先检查该stage依赖并且还没有被计算的父stage，这是通过调用
<code>getMissingParentStages</code> 来完成的，如果所有的父stage都计算完成了，那么就使
用 <code>submitMissingTasks</code> 来将这个stage提交上去, 并且将这个stage放进running
队列里。</li>
<li>submitMissingTasks: 将一个stage拆分成一个一个task，最后调用子类的
submitTasks来提交tasks</li>
</ol></li>
<li>submitTasks: 这个方法在DAGScheduler中没有实现，但是这个需要在子类中实现，在子
类中会根据自己的运行模式来选择适当的方法来运行task。</li>
<li>getMissingParentStages: 这个函数实际上就是沿着依赖链往上遍历，遇到
shuffleDependence那么就创建一个Stage。它内部有一个visit函数，它会依次遍历每个
rdd，接着将这个rdd，如果它发现rdd的所有split在集群的节点上都有cache，那么它直
接返回，否则就检查dependences，如果为窄依赖，那么继续往上遍历，如果为
shuffleDependence那么就创建stage。</li>
</ol>
<p>
下面以MesosScheduler为例来说一说submitTasks的实现：
</p>
<ol class="org-ol">
<li>创建一个SimpleJob</li>
<li>接着启动mesos的SchedulerDriver</li>
</ol>
</div>
</div>
<div id="outline-container-org7015826" class="outline-3">
<h3 id="org7015826">MesosScheduler</h3>
<div class="outline-text-3" id="text-org7015826">
<ol class="org-ol">
<li>createTask: 返回一个mesos要求的TaskInfo</li>
</ol>
</div>
</div>
<div id="outline-container-org4826ebd" class="outline-3">
<h3 id="org4826ebd">Task(task.py)</h3>
<div class="outline-text-3" id="text-org4826ebd">
<p>
一个stage会根据分区拆分成多个task，每个task一般运行于不同的机器，所以task实际上
就是mesos中的运行单元，mesos的scheduler得到资源后就会提交一个task。注意这里的
task和mesos的taskInfo不是一回事，实际上这里的task对象会被序列化并且压缩后塞进
taskInfo的data属性上，这样通过mesos，executor就可以通过解压反序列化来重建task对
象，Task类有两个子类，类的run方法就是实际执行运算的方法
</p>
<ol class="org-ol">
<li>ResultTask: 在finalStage上就会创建这种task，它的run方法很简单，就是在分区上应
用传入的func。</li>
<li>ShuffleMapTask: 一个ShuffleMapTask只会处理父RDD的一个分区，它遍历这个分区中的
所有元素，然后根据partitioner来确定各个元素应该放到当前rdd的哪个分区，最后把
每个分区的结果都存到一个单独的文件中，后面的计算就可以通过shuffleFetcher来合
并分散在各个节点的分区元素。</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org9ec1de1" class="outline-2">
<h2 id="org9ec1de1">Executor(executor.py)</h2>
<div class="outline-text-2" id="text-org9ec1de1">
</div>
<div id="outline-container-org2b0c9e0" class="outline-3">
<h3 id="org2b0c9e0">web server</h3>
<div class="outline-text-3" id="text-org2b0c9e0">
<p>
在executor中启动了一个http server，这个server是用来获取本地文件系统的中的文件,
也就是work_dir中的文件的。
</p>
</div>
</div>
<div id="outline-container-org05c3bc6" class="outline-3">
<h3 id="org05c3bc6">进程池</h3>
<div class="outline-text-3" id="text-org05c3bc6">
<p>
executor用一个进程池来运行task，这个进程池的创建主要在get_idle_workers中，使用
multiprocess的pool来创建的。之所以用进程池也是为了规避GIL的影响。多线程无法利用
多核的优势。在初始化process时先运行init_env，它会初始化dpark.env
</p>
</div>
</div>
<div id="outline-container-org0a9834a" class="outline-3">
<h3 id="org0a9834a">run_task</h3>
<div class="outline-text-3" id="text-org0a9834a">
<p>
这个函数就是运行task的关键函数。
</p>
</div>
</div>
<div id="outline-container-org705e1ff" class="outline-3">
<h3 id="org705e1ff">MyExecutor</h3>
<div class="outline-text-3" id="text-org705e1ff">
<p>
这是按mesos的要求实现的Executor类
</p>
<ol class="org-ol">
<li>registered: 这个函数主要用来干这几件事：
<ul class="org-ul">
<li>从ExecutorInfo变量中获得osenv以及env.environ，前者用来设置进程的环境变量，
后者用来初始化env.py中env。</li>
<li>修改env中的SERVER_URI, 因为shcudler传过来的是一个file类型的url这是不符合要
求的，所以根据workdir来修改为http类型的url，同时启动一个webserver来</li>
</ul></li>
<li>launchTask: 用来启动task，内部定义了一个callback，接着以异步的方式启动run_task</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_comment">
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        var url_path = window.location.pathname;
        var disqus_identifier = url_path.substring(url_path.lastIndexOf('/')+1);
        disqus_identifier? disqus_identifier: 'index';

        var full_url = window.location.href.replace(/^http:/, 'https:');
        this.page.url = full_url;
        this.page.identifier = disqus_identifier;
        // this.page.title = document.title;
    };

    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');

        s.src = '//yuyang.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
<!-- begin footer -->
<div id="footer">
  <ul class="links vertical-nav">
    <li><a href="/sitemap.xml">Sitemap</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    <li><a href="/about.html">About Me</a></li>
    <li><a class="back-to-top" href="#">Back to Top</a></li>
  </ul>
  <span>© 2013 Yu Yang's Blog, Created by org-mode and dropbox</span>
  <a href="#" class="back-to-top" id="fixed-back-to-top" ></a>
</div>
<script src="//apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js"></script>
<script type="text/javascript">
	window.jQuery || document.write('<script src="static/js/jquery-2.0.0.min.js"><\/script>');
	</script>
<script type="text/javascript" src="static/js/custom.js"></script>
<!-- end footer -->
</div>
</body>
</html>